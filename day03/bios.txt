1. CPU手册中，启动后初始化完成，CPU处于一种状态，如CS、EIP、实地址模式，所以要求CS：EIP处有代码。
2. IBM研究第一台PC时，启动、加载、前导程序、基本外围I/O处理子程序，32KPROM，BIOS，BIOS芯片。此BIOS处在CS：EIP处。
3. 主板除BIOS之外，显卡、SCSI控制卡、磁盘附加卡、高级网卡也都有自己的BIOS芯片。System BIOS/Mainboard BIOS，Video BIOS， SCSI BIOS。
4. BIOS的叙述：A Firmware program（一种属于ROM的程序代码），存储在ROM、ERPOM或FlashROM内存中，提供最基本的硬件初始化、外围控制的必要程序代码。通常是用汇编语言编写的。
5. Windows 95 流行之后，由于PnP与ACPI以及DMI协议的需要，主板中需要有一个可以记录外围设备资源的异动情况，却又不会被其他程序所破坏的内存区域。FlashROM更方便。
6. 主板BIOS最重要的工作：1.POST 2.Initial 3.记录系统设置 4. 将常驻程序库常驻于某一段内存中。如INT 10h之类。
7. 随着外围设备的增加，主板的功能包罗万象，BIOS把有些功能保留到设备安装上时才启用，BIOS把外围设备大大小小的设置项目，分类并提供用户选择并保存到CMOS芯片内。
8. 主板负责处理器、内存、显卡与外部接口的联系的电路板。芯片组，负责各种组件之间的连接，后简化北桥与南桥。独立型芯片组与整合型芯片组，整合体积小，方便。独立利于扩充。
   后增加了各种接口：Supreme I/O，USB，ACPI等。

【下面是重点】
BIOS开发与硬件之间的互动关系
9. 几十年的演变，不可避免地要背包袱，主板结构、功能差异，主要取决于CPU本身，其次主板芯片组。CPU，微码更新。
10. CPU的设计，最早地址20条，一开机0FFFF0H，后面只有16bytes的空间。第一个创造BIOS的是蓝色巨人IBM，烧入EPROM芯片，然后译码到FE000h（第1016K）~FFFFFh（1024K）8K。
11. 随着芯片组的增加，cpu的更新，代码越来越大，分模块，导入压缩的概念，有 一段时间处在64k-128k之间，随后Windows95，PnP，ACPI，USB有些达到512k。

MemorySizing（内存容量检测）与A20开关与保护模式切换
12. 286地址线24条。最大寻址16M。需要保护模式，开机实地址模式，沿自8086的FFFF：0010-FFFF：FFFF表示100000h-10FFEFh，最大约1024K+64K-16=1088K，以往超出的地址绕回，00000h-0FFEFh。286以上的CPU在地址线A20-Axx设计了一个开关，所谓的A20快关：可以强制归零或可进位。强制归零，模仿8086/88的内存的绕回。进位，实地址模式下，多出64K。286要搜寻1M（A20 off）或1M+64K（A20 on）以外的内存区域，如检查有没有安装扩展内存，以及确定安装了多少容量的DRAM内存（Memory Sizing），得进入保护模式，但由于286硬件特性，从实地址模式切换到保护模式后，除非Reset，要不然无法切回实模式，IBM通过8042来弥补。386实现了保护模式到实模式的切换，386的BIOS可以考虑是否兼容的问题了。

ROMCS#，Shadow RAM（影射内存）
以后再研究。

保护模式：
当Intel把80286推出时，其地址空间变成24位，从8086的20位到24位，实际上段寄存器和指针都被加大了，出于保护或兼容的原因，加大的部分没有被程序看见，到了80386，又加大到32位。
在8086中，CPU只用“看得见的部分“，但80286以后，在“看不见的部分”中已经包含了地址值，“看得见的部分”就退化为只是一个标号，再也不参与地址运算。［见Intel手册，第三卷，3.4.3 Segment Registers］也就是说，80286，在实模式下，当一个段寄存器被装入一个值时，“看不见的部分”的界限被设置成FFFFH，基址部分将装入值左移4位，属性部分设置成16位0特权级。这个过程与保护模式时装入一个段寄存器是同理的，只是保护模式的“不可见部分”是从描述表中取值，而实模式是一套固定的过程。
对于CPU在形成地址时，是没有实模式和保护模式之分的，他只管用基址（存在与”不可见部分“）去加上偏移量。实模式与保护模式的差别实际上只是保护处理部件是否工作得更精确而已，比如不允许代码段的写入。实模式下的段寄存器装入有固定的形成办法，从而也就不需要保护模式的“描述符”了，因此，保持了与8086/8088的兼容性。
从上面的”整个段寄存器“可见，CPU的地址形成与”看得见部分“的当前值毫无关系。这也解释了为什么在刚进入保护模式时，后面的代码依然被正确的运行（因为段寄存器没有重新加载，基址也就没变）。所以，从保护模式回来后，如果段寄存器没有重新加载，那CPU依然能够访问整个4G内存。
